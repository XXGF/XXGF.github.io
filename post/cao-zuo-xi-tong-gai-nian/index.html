<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>操作系统概念 | Gridea</title>
<link rel="shortcut icon" href="https://xxgf.github.io//favicon.ico?v=1727422712163">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xxgf.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="操作系统概念 | Gridea - Atom Feed" href="https://xxgf.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="虚拟内存
虚拟内存是计算机系统内存管理的一个特性，它允许一个程序在执行时感觉到它拥有一块连续的、独立的内存区域，即使物理内存可能是分散的，甚至部分存储在磁盘上。这个概念可以从几个方面来理解：
1. 抽象层
虚拟内存为每个程序提供了一个统一的..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xxgf.github.io/">
  <img class="avatar" src="https://xxgf.github.io//images/avatar.png?v=1727422712163" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="/note" class="menu">
          笔记
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              操作系统概念
            </h2>
            <div class="post-info">
              <span>
                2024-03-04
              </span>
              <span>
                7 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h1 id="虚拟内存">虚拟内存</h1>
<p>虚拟内存是计算机系统内存管理的一个特性，它允许一个程序在执行时感觉到它拥有一块连续的、独立的内存区域，即使物理内存可能是分散的，甚至部分存储在磁盘上。这个概念可以从几个方面来理解：</p>
<h2 id="1-抽象层">1. 抽象层</h2>
<p>虚拟内存为每个程序提供了一个统一的、连续的内存空间抽象，这个空间被称为虚拟地址空间。这意味着程序在编写时不需要关心物理内存的实际情况，如内存的大小或者内存碎片等问题。</p>
<h2 id="2-内存管理">2. 内存管理</h2>
<p>操作系统负责管理虚拟内存和物理内存之间的映射关系。它使用了一种叫做分页（paging）的技术，将虚拟内存分割成多个固定大小的块，称为“页”（pages），同时将物理内存分割成同样大小的“页帧”（page frames）。操作系统和硬件协同工作，确保虚拟页在需要时映射到物理页帧上。</p>
<h2 id="3-内存保">3. 内存保</h2>
<p>虚拟内存机制还提供了内存保护功能。每个进程的虚拟内存空间是独立的，一个进程无法直接访问另一个进程的内存空间，这样可以防止程序间的干扰和潜在的恶意攻击。</p>
<h2 id="4-交换swapping">4. 交换（Swapping）</h2>
<p>当系统的物理内存不足时，操作系统可以将一些不常用的内存页移动到磁盘上的交换空间（swap space）或页面文件（page file）中，这个过程称为“交换”或“换出”（swap out）。当这些页再次需要时，操作系统将它们“换入”（swap in）到物理内存中。这允许系统运行比实际物理内存更大的程序。</p>
<h2 id="5-性能优化">5. 性能优化</h2>
<p>虚拟内存还可以通过各种算法来优化性能，比如最近最少使用（LRU）算法，来决定哪些内存页应该保留在物理内存中，哪些可以被换出。</p>
<h2 id="6-内存过量分配overcommitment">6. 内存过量分配（Overcommitment）</h2>
<p>由于并非所有分配的虚拟内存都会被实际使用，操作系统可以允许内存的过量分配，即分配给进程的虚拟内存总量可以超过物理内存的大小。</p>
<h2 id="总结">总结</h2>
<p>虚拟内存的引入极大地简化了程序的内存管理，提高了计算机系统的安全性和稳定性，并且允许更有效地使用物理内存资源。然而，虚拟内存的使用也可能导致一些性能问题，比如页面交换可能会引起延迟，特别是当物理内存使用接近或超过其容量时。因此，虚拟内存的管理是操作系统和硬件共同努力的结果，需要精心设计以确保系统的响应性和效率。</p>
<h1 id="虚拟内存相关概念">虚拟内存相关概念</h1>
<p>为了进一步理解虚拟内存，我们可以探讨一些与其相关的关键概念：</p>
<h2 id="0-内存页memory-page">0. 内存页（Memory Page）</h2>
<p>内存页（Memory Page）是虚拟内存系统中的一个基本概念。在这个系统中，内存被划分为许多固定大小的块，每个块就是一个“页”。页是内存管理和虚拟地址映射的基本单位。</p>
<p>内存页的使用带来了几个好处：</p>
<ul>
<li>简化内存管理：操作系统不需要跟踪每个字节的使用情况，而是以页为单位管理内存。</li>
<li>支持虚拟内存：程序可以使用比实际物理内存更大的地址空间。</li>
<li>内存保护：操作系统可以控制对每个页的访问权限，防止程序间相互干扰。</li>
<li><strong>高效的磁盘交换：当内存不足时，操作系统可以将整个页交换到磁盘，而不是单个字节，这样可以提高效率。</strong></li>
</ul>
<p>内存页是现代计算机系统中虚拟内存管理的核心，它们使得多任务操作、内存保护和优化等功能成为可能。</p>
<h2 id="1-页表page-table">1. 页表（Page Table）</h2>
<p>操作系统使用页表来跟踪虚拟地址和物理地址之间的映射关系。每当程序尝试访问一个虚拟地址时，硬件会自动查找页表以找到对应的物理地址。如果找不到有效映射，就会发生一个缺页中断（page fault），操作系统必须处理这个中断，可能涉及到从磁盘读取数据到内存中。</p>
<h2 id="2-缺页中断page-fault">2. 缺页中断（Page Fault）</h2>
<p>当程序访问的虚拟内存页不在物理内存中时，就会发生缺页中断。操作系统必须从磁盘上的交换空间中找到相应的页，并将其加载到物理内存中。如果物理内存已满，操作系统可能需要选择一个页将其换出到磁盘，以便为新页腾出空间。</p>
<h2 id="3-内存映射memory-mapping">3. 内存映射（Memory Mapping）</h2>
<p>虚拟内存还允许文件直接映射到进程的地址空间中。这意味着程序可以像访问内存一样访问文件内容，这通常可以提高文件操作的性能，并简化编程模型。</p>
<h2 id="4-写时复制copy-on-write-cow">4. 写时复制（Copy-on-Write, COW）</h2>
<p>这是一种优化策略，当多个进程需要读取相同的数据时，它们可以共享同一物理的内存页。只有当其中一个进程尝试写入这个页时，操作系统才会创建这个页的一个副本，以确保修改不会影响到其他进程。这种方式可以有效地减少物理内存的使用，因为只有在必要时才会进行复制。</p>
<h2 id="5-虚拟内存大小">5. 虚拟内存大小</h2>
<p>虚拟内存的大小通常远大于物理内存。例如，在32位系统中，虚拟地址空间可以达到4GB，而64位系统的理论虚拟地址空间可以达到数百万TB，远远超过现代硬件的物理内存容量。</p>
<h2 id="6-tlbtranslation-lookaside-buffer">6. TLB（Translation Lookaside Buffer）</h2>
<p>为了加快虚拟地址到物理地址的转换过程，现代CPU使用一种称为TLB的缓存。TLB存储了最近使用的页表条目，这样在地址转换时可以快速进行，而不必每次都从内存中读取页表。</p>
<h2 id="7-内存分配">7. 内存分配</h2>
<p>虚拟内存系统允许操作系统进行按需分配（demand paging），即只有当程序实际访问某个内存区域时，这部分内存才会被分配（可能包括从磁盘读取）。这样可以避免分配未使用的内存，提高内存使用效率。</p>
<h2 id="8-虚拟内存的局限性">8. 虚拟内存的局限性</h2>
<p>虚拟内存虽然提供了很多便利，但也有其局限性。例如，如果系统频繁地进行页面交换，会导致系统性能下降，这种现象称为“抖动”（thrashing）。此外，虚拟内存的管理也会消耗一定的CPU资源，因为需要维护页表，处理缺页中断等。</p>
<p>总的来说，虚拟内存是现代计算机系统中一个复杂且至关重要的组成部分，它通过将物理内存的复杂性抽象出来，为应用程序提供了一个简单、连续和安全的内存使用环境。虚拟内存的设计和实现是操作系统设计中的一个核心领域，对于系统的整体性能和稳定性有着直接的影响。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">虚拟内存</a>
<ul>
<li><a href="#1-%E6%8A%BD%E8%B1%A1%E5%B1%82">1. 抽象层</a></li>
<li><a href="#2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">2. 内存管理</a></li>
<li><a href="#3-%E5%86%85%E5%AD%98%E4%BF%9D">3. 内存保</a></li>
<li><a href="#4-%E4%BA%A4%E6%8D%A2swapping">4. 交换（Swapping）</a></li>
<li><a href="#5-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">5. 性能优化</a></li>
<li><a href="#6-%E5%86%85%E5%AD%98%E8%BF%87%E9%87%8F%E5%88%86%E9%85%8Dovercommitment">6. 内存过量分配（Overcommitment）</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">虚拟内存相关概念</a>
<ul>
<li><a href="#0-%E5%86%85%E5%AD%98%E9%A1%B5memory-page">0. 内存页（Memory Page）</a></li>
<li><a href="#1-%E9%A1%B5%E8%A1%A8page-table">1. 页表（Page Table）</a></li>
<li><a href="#2-%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%ADpage-fault">2. 缺页中断（Page Fault）</a></li>
<li><a href="#3-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84memory-mapping">3. 内存映射（Memory Mapping）</a></li>
<li><a href="#4-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6copy-on-write-cow">4. 写时复制（Copy-on-Write, COW）</a></li>
<li><a href="#5-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F">5. 虚拟内存大小</a></li>
<li><a href="#6-tlbtranslation-lookaside-buffer">6. TLB（Translation Lookaside Buffer）</a></li>
<li><a href="#7-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">7. 内存分配</a></li>
<li><a href="#8-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7">8. 虚拟内存的局限性</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xxgf.github.io/post/yun-ji-suan-wei-shi-me-yao-xue-xi-yun-ji-suan/">
              <h3 class="post-title">
                云计算（一）：为什么要学习云计算？
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '346dd1e6861a8d5154be',
    clientSecret: '11fa9ccf79622cb14f892b083428ae40f9f28f13',
    repo: 'XXGF.github.io',
    owner: 'XXGF',
    admin: ['XXGF'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xxgf.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
