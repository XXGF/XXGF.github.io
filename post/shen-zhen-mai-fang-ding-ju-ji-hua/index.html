<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>许式伟的架构课：架构思维 | Gridea</title>
<link rel="shortcut icon" href="https://xxgf.github.io//favicon.ico?v=1727422712163">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xxgf.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="许式伟的架构课：架构思维 | Gridea - Atom Feed" href="https://xxgf.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="五、架构：需求分析
（一）需求分析理论
需求分析问题
需求分析过程会涉及以下内容：

我们要面向的核心用户人群是谁？
用户原始需求是什么？最核心问题是哪几个？
已经有哪些玩家在里面？上下游有哪些类型的公司，在我们之前，用户是怎么解决他们的问..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xxgf.github.io/">
  <img class="avatar" src="https://xxgf.github.io//images/avatar.png?v=1727422712163" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="/note" class="menu">
          笔记
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              许式伟的架构课：架构思维
            </h2>
            <div class="post-info">
              <span>
                2024-02-24
              </span>
              <span>
                17 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h1 id="五-架构需求分析">五、架构：需求分析</h1>
<h2 id="一需求分析理论">（一）需求分析理论</h2>
<h3 id="需求分析问题">需求分析问题</h3>
<p>需求分析过程会涉及以下内容：</p>
<ul>
<li>我们要面向的核心用户人群是谁？</li>
<li>用户原始需求是什么？最核心问题是哪几个？</li>
<li>已经有哪些玩家在里面？上下游有哪些类型的公司，在我们之前，用户是怎么解决他们的问题的？我们的替换方案又是怎样的？</li>
<li>进而，我们的产品创造的价值点是什么？用户最关注的核心指标是什么？</li>
<li>用户需求潜在的变化在哪些地方？区分出需求的变化点和稳定点。</li>
</ul>
<h3 id="怎么做需求分析">怎么做需求分析</h3>
<ol>
<li>除了需要 “在心里对需求反复推敲” 的严谨态度外，对用户反馈的尊重之心也至关重要。</li>
<li>对问题刨根究底，找到根源需求。有很多用户反馈需求的时候，往往已经带着他自己给出的解决方案。这个时候我们要多问多推敲，把它还原到不带任何技术实现假设的根源需求。</li>
<li>在理清楚需求后，要对需求进行归纳整理。一方面，将需求分别归类到不同的子类别中。另一方面，形成需求的变化点和稳定点的基本判断。</li>
</ol>
<p>需求分析关乎的是用户需求的梳理、产品的清晰定义、可能的演变方向。</p>
<p>需求分析的目标和最终结果，都是要最终形成清晰的产品定义。产品定义将明确产品的元素，明确产品的边界，与产业上下游、合作伙伴的分工。</p>
<h3 id="产品定义">产品定义</h3>
<p>需求分析的目标和最终结果，都是要最终形成清晰的产品定义。</p>
<ol>
<li>首先，需要明确产品中有哪些元素，或者叫资源，以及这些资源的各类操作方式。</li>
<li>其次，需要对产品如何满足用户需求进行确认。</li>
<li>最后，产品定义还需要考虑市场策略，我们的产品如何进入市场，和既有市场格局中的其他主流解决方案的关系是什么样的。</li>
</ol>
<h2 id="二需求分析实战">（二）需求分析实战</h2>
<h3 id="案例-打造-互联网">案例: 打造 “互联网”</h3>
<p>怎么才能打造一个连接人与人、企业与企业，甚至是物与物，能够 “连接一切” 的 “互联网”？</p>
<p>所谓 “互联网” 首先应该是一张开放的网。它应该可以让很多国家很多公司参与其中，形成合力。它不应该存在 “造物主”，一个可以在这张网络中主宰一切的人。【即去中心化】</p>
<p>要想把 “互联网” 这个项目做成，需要考虑这样一些事情：</p>
<ul>
<li>一个能够连接所有既有网络的协议标准，我们不妨叫它互联网协议（Internet Protocol），简称 IP 协议。</li>
<li>一张连接城市的骨干网络，至少有两个城市互联的试点。</li>
<li>打通骨干网络和主流企业专用网络的路由器。</li>
<li>一套方便应用开发的高阶网络协议，工作在 IP 协议之上。</li>
<li>一份支撑互联网应用程序的基础网络协议栈源代码或包（package），方便主流操作系统厂商、网络设备厂商集成。</li>
<li>若干典型互联网应用，如电子邮件（Email）、万维网（WWW）等。</li>
<li>一份安全传输的网络协议方案（远期），及其源代码或包（package）。</li>
</ul>
<h3 id="案例存储新兵-对象存储">案例：存储新兵 “对象存储”</h3>
<p>对象存储是非常新兴的一种存储系统。是什么样的需求满足方式的变化，导致人们要创造一种新的存储呢？</p>
<ul>
<li>互联网应用兴起。用户在使用应用软件的过程中产生的数据，并不是跟随设备，而是跟随账号。数据跟随账号，这是互联网应用的第一大特征，区别于单机软件的关键所在。</li>
<li>用户交互方式的变化。用户不再打字用纯文本沟通，而是用照片、视频、语音等多媒体内容来表达自己的想法。</li>
<li>用户体验诉求的提升。随之发生变化的，是一张照片从 100K，到几兆，到几十兆。</li>
</ul>
<p><strong>这些趋势，对存储系统带来的挑战是什么？</strong></p>
<ul>
<li>
<p>其一，规模。那么多用户的数据，一台机器显然放不下了，要很多很多台机器一起来保存。</p>
</li>
<li>
<p>其二，可靠。用户单机对存储的要求并不高，机器硬盘出问题了，不会想着找操作系统厂商或者软件应用厂商去投诉。但是，用户数据在服务端，数据丢了那就是软件厂商的责任，要投诉。</p>
</li>
<li>
<p>其三，成本。从软件厂商来说，那么多的用户数据，怎么做才能让成本更低一些。</p>
</li>
<li>
<p>其四，并发吞吐能力。大量的用户同时操作，有读有写，怎么保证系统是高效的。</p>
</li>
</ul>
<p><strong>文件系统（FileSystem）对于大规模的文件型存储来说有什么问题?</strong><br>
文件系统是一棵树（Tree）。除了对单个文件的操作只需要锁住该文件外，所有对树节点的修改操作，比如把 A 节点移到 B 处，都是一次事务操作，需要锁住整棵树。</p>
<p>这对规模和并发吞吐能力都是伤害。</p>
<p><strong>对象存储的优势</strong><br>
对象存储打破了文件型存储访问接口一定是文件系统（FileSystem）的惯例。它用的是键值存储（Key-Value Storage）。</p>
<p>从使用接口来说，首先选择文件所在的桶（Bucket），它类似于数据库的表（Table），只是一个逻辑划分的手段；然后选择文件的键（Key），就可以存取文件了。<br>
这意味着文件之间并不存在关联（树型结构是文件之间的一种关联），可以通过某种算法将文件元信息分散到不同的机器上。</p>
<hr>
<h1 id="一-需求的稳定点和变化点">一、需求的稳定点和变化点</h1>
<p>架构的第一步是需求分析。从需求分析角度来说，关键要抓住需求的稳定点和变化点。<br>
需求的稳定点，往往是系统的核心价值点；而需求的变化点，则往往需要相应去做开放性设计。</p>
<p>对于“电脑”这个产品而言：</p>
<ul>
<li>需求的稳定点是电脑的“计算”能力。</li>
<li>需求的变化点，一是用户“计算”需求的多样性，二是用户交互方式的多样性。</li>
</ul>
<p>电脑的“计算”能力，最终体现为中央处理器的指令集，这是需求相对稳定的部分。</p>
<p>用户“计算”需求的多样性，最终是通过在存储中的指令序列实现。计算机加电启动后，中央处理器并不是按自己固有的“计算”过程进行，而是从一个固定的存储地址加载指令序列执行。</p>
<h1 id="二-语言对架构的影响是什么">二、语言对架构的影响是什么？</h1>
<p>站在唯技术论的角度，业务架构与语言无关。<br>
语言影响的只是模块规格的描述语法，但语言的选择在实践中对业务架构决策的影响仍然极其关键。</p>
<ul>
<li>
<p>原因之一是开发效率。<br>
抛开语言本身的开发效率差异不谈，不同语言会有不同的社区资源。语言长期以来的演进，社区所沉淀下来的框架和基础库，还有你所在的企业长期发展形成的框架和基础库，都会导致巨大的开发效率上的差异。</p>
</li>
<li>
<p>原因之二是后期维护。<br>
语言的历史通常都很悠久，很难实质性地消亡。但是语言的确有它的生命周期，语言也会走向衰落。选择公司现在更熟悉的语言，还是选择一个面向未来更优的语言，对架构师来说也是一个两难选择。</p>
</li>
</ul>
<h1 id="三-架构实践如何实现可自我迭代的计算机">三、架构实践：如何实现可自我迭代的计算机?</h1>
<h2 id="需求背景">需求背景</h2>
<p>第一台以键盘 + 显示器为标准输入输出的现代计算机出现后，一个最小功能集，但计算能力可自我迭代的计算机应该是什么样的？</p>
<p>从需求上来说，我们期望它有如下能力。</p>
<ul>
<li>键盘和显示器的驱动程序。</li>
<li>当时最主流的外置存储设备（不一定是现代的硬盘）的驱动程序。</li>
<li>一个汇编程序编辑器。可从存储中读取汇编程序代码，修改并保存到存储中。</li>
<li>一个汇编编译器。可将汇编程序代码编译成机器代码程序，并保存到存储中。</li>
<li>支持执行一段保存在外置存储设备中的机器代码程序。</li>
</ul>
<h2 id="需求分析">需求分析</h2>
<p><strong>做架构，第一件事情要学会做需求分析。</strong></p>
<p>在需求分析时，要区分需求的变化点和稳定点。稳定点往往是系统的核心能力，而变化点则需要对应地去考虑扩展性上的设计。</p>
<h2 id="怎么实现可自我迭代的计算机">怎么实现可自我迭代的计算机？</h2>
<p>通过前面对计算机工作原理的分析，我们已经知道，计算机分为三大类的零部件：</p>
<ul>
<li>中央处理器</li>
<li>存储
<ul>
<li>计算机主板 ROM 上的启动程序（BIOS）</li>
<li>外置存储上的软件</li>
</ul>
</li>
<li>输入输出设备
<ul>
<li>键盘</li>
<li>鼠标</li>
<li>外置存储</li>
</ul>
</li>
</ul>
<p>外置存储在我们为它准备好了驱动程序后，就可以对它进行数据的读写了。</p>
<p>但是我们接着需要考虑的问题是：<strong>我们准备把外置存储的数据格式设计成什么样？</strong></p>
<p>回答这个问题前，先回顾下我们要做什么。目前我们已知的功能需求有如下这些。</p>
<ul>
<li>键盘和显示器的驱动程序。</li>
<li>外置存储设备的驱动程序。</li>
<li>汇编程序编辑器。可从外置存储中读取汇编程序代码，修改并保存到外置存储中。</li>
<li>汇编编译器。可将汇编程序代码编译成机器代码程序，并保存到外置存储中。</li>
<li>支持执行一段保存在外置存储设备中的机器代码程序。</li>
</ul>
<p>我们可以看到，外置存储需要保存的内容有：</p>
<ul>
<li>汇编程序的源代码</li>
<li>汇编编译器，编译出来的可执行程序</li>
</ul>
<p>可见，外置存储它不应该只能保存一个文件，而是应该是多个。<strong>既然是多个，就需要组织这些文件。那么，怎么组织呢？</strong></p>
<blockquote>
<p>操作系统的设计者们设计了文件系统这样的东西，来组织这些文件。虽然文件系统的种类有很多（比如：FAT32、NTFS、EXT3、EXT4 等等），但是它们有统一的抽象：文件系统是一颗树；节点要么是目录，要么是文件；文件必然是叶节点；根节点是目录，目录可以有子节点。<br>
文件系统（File System）是否是唯一的可能性？当然不是。键值存储（Key-Value 存储）也挺好，尤其是早期外置存储容量很可能极其有限的情况下。</p>
</blockquote>
<p>聊完了外置存储，让我们再回来看看： <strong>BIOS 和外置存储的软件怎么分工</strong>。</p>
<blockquote>
<p>BIOS 是刻在计算机主板 ROM 上的启动程序，它的变更非常麻烦。所以 BIOS 负责的事情最好越少越好，只做最稳定不变的事情。<br>
首先是外部设备的驱动程序：键盘和显示器的驱动程序、外置存储设备的驱动程序。一方面，只要键盘、显示器、外置存储没有大的演进，驱动程序就不变，所以这块是稳定的；另一方面，它们是 BIOS 干其他业务的基础。所以，这个事情 BIOS 必然会做。<br>
其次是汇编程序编辑器。编辑器的需求是模糊的，虽然我们知道它支持用户来编写程序，但是整个编辑器的操作范式是什么样的，没有规定。所以它不像是给键盘写一个驱动程序那样，是一个确定性的需求，而有很多额外的交互细节，需要去进一步明确。<br>
再次是汇编编译器。汇编编译器从输入输出来看，似乎需求相对确定。输入的是汇编源代码，输出的是可执行程序。但认真分析你会发现，它实际上也有很大的不确定性。<br>
其一，CPU 会增加指令，这时候汇编指令也会相应地增加。对于大部分应用程序，CPU 新增的指令如果自己用不到，可以当它不存在。但是汇编语言及编译器需要完整呈现 CPU 的能力，因此需要及时跟进。<br>
其二，虽然汇编指令基本上和机器指令一一对应，但是它毕竟是面向程序员的生产力工具，所以汇编语言还是会演进出一些高阶的语法，比如宏汇编指令。<br>
所谓宏汇编指令，就是用一个命令去取代一小段汇编指令序列，它和 C 语言里面的宏非常类似。所以汇编语言并不是稳定的东西，它和其他高级语言类似，也会迭代变化。这就意味着汇编编译器也需要相应地迭代变化。<br>
最后，执行一段保存在外置存储设备中的机器代码程序。这个需求看似比较明确，但是实际上需求也需要进一步细化。它究竟是基于外置存储的物理地址来执行程序，还是基于文件系统中的文件（文件内容逻辑上连续，但是物理上很可能不连续）来执行程序？实现上，这两者有很大的不同。前者只需要依赖外置存储的驱动程序就可以完成，后者则还需要额外理解文件系统的格式才能做到。</p>
</blockquote>
<p><strong>那么，BIOS 到底怎么把执行控制权交到外置存储呢？</strong></p>
<p>在学冯·诺依曼结构的时候，我们提到过，CPU 加电启动时，它会从存储的一个固定地址开始执行指令，这个固定地址指向的正是 BIOS 程序。</p>
<p>类似的，我们的 BIOS 也可以认定一个外置存储的固定地址来加载程序并执行，而无需关心磁盘的数据格式是什么样的。这个固定地址所在的数据区域，我们可以把它叫做引导区。</p>
<p>引导区的存在非常重要，它实际上是 BIOS 与操作系统的边界。</p>
<p>对于 BIOS 来说，执行外置存储上的程序能力肯定是需要具备的，否则它没有办法把执行权交给外置存储。但是这个能力可以是非常简约的。BIOS 只需要执行引导区的程序，这个程序并不长，完全可以直接读入到内存中，然后再执行。</p>
<p>我们是否需要基于文件系统中的文件来执行程序的能力？答案是需要。因为汇编编译器编译后的程序在外置存储中，需要有人能够去执行它。</p>
<p>综上，我们确认 BIOS 需要负责的事情是：</p>
<blockquote>
<p>键盘和显示器的驱动程序；<br>
外置存储设备的驱动程序；<br>
支持执行外置存储中引导区的机器代码程序；<br>
跳转到外置存储的固定地址，把执行权交给该地址上的引导程序。</p>
</blockquote>
<p>而汇编程序编辑器、汇编编译器 ，以及支持执行文件系统中的程序，则不应该由 BIOS 来负责。</p>
<p>那么，外置存储上的引导程序拿到执行权后干什么呢？</p>
<p>我们再来总结下当前我们遇到的需求。</p>
<blockquote>
<p>需要有人负责支持外置存储的数据格式，提供统一的功能给其他程序使用。无论它是文件系统，还是 Key-Value 存储系统。<br>
需要有人提供管理外置存储的基础能力，比如查询（List）一下外置存储里面都有些什么文件。它可以实现为一个独立的程序，比如我们命名为 ls。<br>
需要有人执行外置存储上的可执行程序。它可以实现为一个独立的程序，比如我们命名为 sh。<br>
汇编程序编辑器。其实这个程序和汇编语言没什么关系，就是一个纯正的文本编辑器。我们可以把这个程序命名为 vi。<br>
汇编编译器。它可以实现为一个独立的程序，比如我们命名为 asm。</p>
</blockquote>
<p><strong>引导程序拿到执行权后，我们不管它额外做了哪些事情，最终它要把执行权交给 sh 程序。因为，sh 程序算得上是可自我迭代的计算机扩展性的体现：通过 sh 程序来执行外置存储上的任意程序，这也相当于在扩展 CPU 的指令集。</strong></p>
<h2 id="实现方案">实现方案</h2>
<ul>
<li>外置存储的数据格式。对此，我们设计文件系统（或 Key-Value 存储）子系统来负责这件事情。另外，我们也提供了 ls 程序来管理外置存储中的文件。</li>
<li>用户最终拿到这个计算机后，会迭代出什么能力。对此，我们设计了 sh 程序，让它支持在外置存储上执行任何应用程序。</li>
<li>编辑器的交互范式。对此，我们设计了 vi 程序，让它迭代编辑器的能力。</li>
<li>汇编语言的使用范式。对此，我们设计了 asm 程序，让它响应 CPU 指令集的迭代，以及汇编语言进化的迭代。</li>
</ul>
<p>最终，我们设计出来的“可自我迭代的计算机”，它的系统架构看起来是这样的：<br>
<img src="https://xxgf.github.io//post-images/1709010816343.webp" alt="" loading="lazy"></p>
<p><strong>需求本身就是，从模糊到细化并最终清晰定义的过程。</strong></p>
<h1 id="四-虚拟内存">四、虚拟内存</h1>
<p>虚拟内存它本质上要解决这样两个很核心的需求。</p>
<ul>
<li>
<p>其一，软件越来越大，我们需要考虑在外置存储上执行指令，而不是完整加载到内存中。<br>
但是外置存储一方面它的数据 CPU 并不知道怎么读；另一方面就算知道怎么读，也不知道它的数据格式是什么样的，这依赖文件系统的设计。让 CPU 理解外置存储的实现细节？这并不是一个好的设计。</p>
</li>
<li>
<p>其二，要同时运行的软件越来越多，计算机内存的供给与软件运行的内存需求相比，捉襟见肘。<br>
怎么才能把有限的内存的使用效率最大化？一个很容易想到的思路是把不经常使用的内存数据交换到外置存储。但是问题仍然是，CPU 并不了解外置存储的实现细节，怎么才能把内存按需交换出去？</p>
</li>
</ul>
<p>通过把虚拟内存地址分页，引入缺页中断，我们非常巧妙地解决了这个问题。缺页中断很像是 CPU 留给操作系统的回调函数，通过它对变化点实现了很好的开放性设计。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%BA%94-%E6%9E%B6%E6%9E%84%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">五、架构：需求分析</a>
<ul>
<li><a href="#%E4%B8%80%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA">（一）需求分析理论</a>
<ul>
<li><a href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98">需求分析问题</a></li>
<li><a href="#%E6%80%8E%E4%B9%88%E5%81%9A%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">怎么做需求分析</a></li>
<li><a href="#%E4%BA%A7%E5%93%81%E5%AE%9A%E4%B9%89">产品定义</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98">（二）需求分析实战</a>
<ul>
<li><a href="#%E6%A1%88%E4%BE%8B-%E6%89%93%E9%80%A0-%E4%BA%92%E8%81%94%E7%BD%91">案例: 打造 “互联网”</a></li>
<li><a href="#%E6%A1%88%E4%BE%8B%E5%AD%98%E5%82%A8%E6%96%B0%E5%85%B5-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8">案例：存储新兵 “对象存储”</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%80-%E9%9C%80%E6%B1%82%E7%9A%84%E7%A8%B3%E5%AE%9A%E7%82%B9%E5%92%8C%E5%8F%98%E5%8C%96%E7%82%B9">一、需求的稳定点和变化点</a></li>
<li><a href="#%E4%BA%8C-%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%9E%B6%E6%9E%84%E7%9A%84%E5%BD%B1%E5%93%8D%E6%98%AF%E4%BB%80%E4%B9%88">二、语言对架构的影响是什么？</a></li>
<li><a href="#%E4%B8%89-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%87%AA%E6%88%91%E8%BF%AD%E4%BB%A3%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA">三、架构实践：如何实现可自我迭代的计算机?</a>
<ul>
<li><a href="#%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF">需求背景</a></li>
<li><a href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">需求分析</a></li>
<li><a href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%87%AA%E6%88%91%E8%BF%AD%E4%BB%A3%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA">怎么实现可自我迭代的计算机？</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">实现方案</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">四、虚拟内存</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xxgf.github.io/post/zuo-er-ting-feng-shi-fen-bu-shi-xi-tong/">
              <h3 class="post-title">
                左耳听风（十）：分布式系统
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '346dd1e6861a8d5154be',
    clientSecret: '11fa9ccf79622cb14f892b083428ae40f9f28f13',
    repo: 'XXGF.github.io',
    owner: 'XXGF',
    admin: ['XXGF'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xxgf.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
