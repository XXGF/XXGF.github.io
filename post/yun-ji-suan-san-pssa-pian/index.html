<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>云计算（三）：PaaS篇 | Gridea</title>
<link rel="shortcut icon" href="https://xxgf.github.io//favicon.ico?v=1727422712163">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xxgf.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="云计算（三）：PaaS篇 | Gridea - Atom Feed" href="https://xxgf.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="什么是PaaS
在 IaaS 篇中，我们主要是侧重于基础设施类的云服务，尤其是虚拟机、云磁盘、云网络等服务。它们的特点是，和传统 IT 基础设施往往有一个对应关系，所以被称为基础设施即服务（Infrastructure-as-a-Servi..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xxgf.github.io/">
  <img class="avatar" src="https://xxgf.github.io//images/avatar.png?v=1727422712163" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="/note" class="menu">
          笔记
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              云计算（三）：PaaS篇
            </h2>
            <div class="post-info">
              <span>
                2024-03-12
              </span>
              <span>
                7 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h1 id="什么是paas">什么是PaaS</h1>
<p>在 IaaS 篇中，我们主要是侧重于基础设施类的云服务，尤其是虚拟机、云磁盘、云网络等服务。它们的特点是，和传统 IT 基础设施往往有一个对应关系，所以被称为基础设施即服务（Infrastructure-as-a-Service）。</p>
<p>PaaS （Platform-as-a-Service），则是指云计算提供的平台类服务，在这些平台的基础上，用户可以直接开发、运行、管理应用程序，而无需构建和维护底层的基础设施。</p>
<p><strong>PaaS 是在 IaaS 的基础上又做了许多工作，构建了很多关键抽象和可复用的单元，让我们用户能够在更上层进行应用的构建，把更多精力放在业务逻辑上。</strong></p>
<h1 id="对象存储">对象存储</h1>
<p>云硬盘其实是挂载到虚拟机的虚拟硬盘，它是通过实现操作系统级别的底层接口，作为虚拟机的块存储设备而存在。我们也必须连接到相关的虚拟机，才能访问它里面的数据。<br>
而对象存储，本质是一个网络化的服务，调用方主要通过高层的 API 和 SDK 来和它进行交互。不管是面向外部公开互联网服务，还是和内部应用程序对接，对象存储都是通过提供像HTTP 这样的网络接口来实现的。</p>
<blockquote>
<p>尽管有 S3FS、OSSFS 等工具也可以模拟磁盘并挂载到虚拟机，但它们也是基于对象存储的 API 进行了封装，并不改变对象存储是网络化服务的本质。</p>
</blockquote>
<p>对象存储的一大特征，就是对象存储内本身不存在一个真正的文件系统，而是更接近一个键值（Key-Value）形式的存储服务。</p>
<p>作为云计算最具代表性的服务之一，它的可扩展性（Scalability）是毋庸置疑的，对象存储能够轻松地容纳上 PB 的超大容量数据，这是任何的云硬盘所不能企及的。所以对象存储是名副其实的大数据存储。</p>
<h1 id="应用托管">应用托管</h1>
<h1 id="云数据库">云数据库</h1>
<p>云数据库和传统数据库有很大的区别，这是指在搭建、运维、管理层面，云数据库提升了一个层次，实现了相当程度的智能化和自动化，极大地提升了用户友好度，降低了使用门槛。比如灵活的性能等级调整、详尽的监控体系、攻击防护机制等等，这些许多在传统数据库中需要借助额外工具或产品的功能，在云数据库服务是默认内置，可以开箱即用的。<br>
两个特性：</p>
<ul>
<li>读写分离</li>
<li>自动调优</li>
</ul>
<h1 id="云上大数据">云上大数据</h1>
<p>云计算以存储、计算规模和弹性著称，而大数据方面的业务需求，恰恰需要大量的存储，和呼之即来的澎湃算力。</p>
<p>云计算和大数据的区别：</p>
<ul>
<li>大数据主要是技术手段，是一系列处理海量数据的方法论和技术实现的总称；</li>
<li>云是一种资源和能力的载体，也是一种商业存在，是可以运行大数据负载和应用的平台。</li>
</ul>
<h1 id="云上容器">云上容器</h1>
<p>云可以说是容器应用的最佳载体，容器应用也非常适合在云上运行和扩展。</p>
<p>在 Docker 技术家喻户晓之前，云厂商已经在研究和使用类似容器的技术了，因为云本身是多租户的，需要运行环境的隔离性。所以云本身也是容器技术的用户和受益者，只是部分厂商会考虑进行自研，未必直接使用 Docker 而已。</p>
<h2 id="docker-和-k8s-的区别与联系">Docker 和 K8S 的区别与联系</h2>
<p>Docker是一种开源的容器化平台，它提供了一种轻量级的虚拟化技术，使开发人员能够将应用程序及其依赖项打包成一个独立的容器。Docker容器包含了应用程序的代码、运行时环境和所需的库和依赖项，可以在任何支持Docker的环境中运行，而不受底层操作系统的限制。</p>
<p>Kubernetes是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。它提供了一种集群管理的方式，可以在多个主机上运行和管理大规模的容器化应用程序。</p>
<p>区别：</p>
<ul>
<li>Docker是一种容器化技术，用于打包和运行应用程序，而Kubernetes是一个容器编排平台，用于管理和调度容器化应用程序。</li>
<li>Docker关注于单个容器的创建、运行和管理，而Kubernetes关注于多个容器的编排、调度和管理。</li>
</ul>
<p>联系：</p>
<ul>
<li>Kubernetes可以使用Docker作为其容器运行时环境，通过Docker来创建和管理容器。</li>
<li>Kubernetes可以与Docker Hub等Docker镜像仓库集成，方便地获取和使用Docker镜像。</li>
<li>Kubernetes可以通过Docker的API进行与容器的交互和管理。</li>
</ul>
<h2 id="什么是容器编排">什么是容器编排</h2>
<p><strong>容器编排</strong>是指自动化管理和调度容器化应用程序的过程。它涉及到在一个集群中部署、扩展和管理多个容器实例，以确保应用程序的高可用性、负载均衡和弹性伸缩。</p>
<p><strong>举个例子：</strong><br>
假设有一个Web应用程序，由多个微服务组成，每个微服务都可以打包为一个独立的容器。在容器编排中，可以使用工具如Kubernetes来管理这些容器。</p>
<p>首先，需要定义一个包含所有微服务的应用程序描述文件，通常使用YAML或JSON格式。该描述文件指定了每个微服务的容器镜像、资源需求、网络配置等信息。</p>
<p>然后，使用容器编排工具将这个描述文件部署到一个容器编排平台上，如Kubernetes集群。容器编排工具会根据描述文件的定义，自动创建和管理容器实例。</p>
<p>容器编排工具会根据定义的规则和策略，自动进行以下操作：</p>
<ul>
<li>调度和部署：根据资源需求和可用性，将容器实例分配到集群中的不同节点上，确保应用程序的高可用性和负载均衡。</li>
<li>伸缩：根据应用程序的负载情况，自动扩展或缩减容器实例的数量，以满足需求并提供弹性。</li>
<li>服务发现和负载均衡：容器编排工具会自动为每个容器实例分配一个唯一的网络地址，并提供服务发现和负载均衡功能，使应用程序能够相互通信和提供服务。</li>
<li>健康检查和自愈：容器编排工具会定期检查容器实例的健康状态，如果发现故障或异常，会自动重启或替换容器实例，以确保应用程序的稳定性和可靠性。</li>
</ul>
<p>通过容器编排，可以实现高度自动化和可伸缩的容器化应用程序管理。它简化了应用程序的部署和管理过程，提供了弹性和高可用性，并提供了一致的开发和运维体验。</p>
<h1 id="无服务器计算">无服务器计算</h1>
<p>“无服务器”是云计算中资源抽象的极致体现。从它的命名上你就可以看出，所谓“无服务器”就是想让用户感觉不到服务器的存在，这是因为有一朵巨大的云在底层进行着支撑。这样你可以完全专注于业务逻辑的编写，而不再关心任何基础设施。</p>
<h1 id="云上ai服务">云上AI服务</h1>
<p>AI 相关的 PaaS 服务。它们其实也大致分为两类：</p>
<ul>
<li>一类是各种成熟能力的开放，是云厂商已经构建好的现有模型和 API；</li>
<li>另一类则是机器学习的全生命周期管理支撑平台，可以帮助你构建属于自己的机器学习模型。</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFpaas">什么是PaaS</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8">对象存储</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E6%89%98%E7%AE%A1">应用托管</a></li>
<li><a href="#%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93">云数据库</a></li>
<li><a href="#%E4%BA%91%E4%B8%8A%E5%A4%A7%E6%95%B0%E6%8D%AE">云上大数据</a></li>
<li><a href="#%E4%BA%91%E4%B8%8A%E5%AE%B9%E5%99%A8">云上容器</a>
<ul>
<li><a href="#docker-%E5%92%8C-k8s-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB">Docker 和 K8S 的区别与联系</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92">什么是容器编排</a></li>
</ul>
</li>
<li><a href="#%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A1%E7%AE%97">无服务器计算</a></li>
<li><a href="#%E4%BA%91%E4%B8%8Aai%E6%9C%8D%E5%8A%A1">云上AI服务</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xxgf.github.io/post/yun-ji-suan-er-iaas-pian/">
              <h3 class="post-title">
                云计算（二）：IaaS篇
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '346dd1e6861a8d5154be',
    clientSecret: '11fa9ccf79622cb14f892b083428ae40f9f28f13',
    repo: 'XXGF.github.io',
    owner: 'XXGF',
    admin: ['XXGF'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xxgf.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
